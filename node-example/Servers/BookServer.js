const express = require('express');
const bodyParser = require('body-parser');
const cors = require('cors');

const Kerberos = require('./Kerberos-JS');

//* Our Mock DB
//? in real application, we would try to connect to MongoDB or MySQL or some other DB instead of this
let data = ['Gravitation', 'Spacetime And Geomatry'];

const app = express();
const EXPRESS_PORT = process.env.PORT || 5003;
app.use(bodyParser.urlencoded({ extended: false }));
app.use(bodyParser.json());

//* Create Kerberos server class instance using default LocalDB
//? This requires that the ticket generated by TGS for this server must be kept in  Folder name 'Tickets'
//? which is directly inside project root folder (not nested in any other folder)
const server = Kerberos.Server.MakeServerFromDB('Books', null, null, true);

app.post('/data', (req, res) => {
  const inReq = req.body.req;
  const { ticket, user } = req.body;
  //* Sanity check
  if (!inReq || !ticket || !user) {
    return res.status(400).send({ success: false, err: 'Incomplete Fields' });
  }

  try {
    let uid2 = req.ips[0] || req.ip;

    //* decrypt the request (data not http) using the key of this server
    let decReq = server.decryptReq(user, uid2, ticket, inReq);

    //* Then we verify that the random number used by user is used for the first time
    server.verifyRand(user, uid2, decReq.rand);

    //* we encrypt the response (data not http)
    const encRes = server.encryptRes(user, uid2, ticket, data);

    //* Send the actual http response
    return res.status(200).send({ success: true, res: encRes });
  } catch (e) {
    //* If error is of type ServerError, it means ther is some error in decoding the ticket
    if (e instanceof Kerberos.ServerError) {
      //? send the error as reponse, can be encrypted, but not done here
      return res.status(400).send({ success: false, err: e.message });
    } else {
      //* Some other error occurred
      throw e;
    }
  }
});

app.post('/add', (req, res) => {
  const inReq = req.body.req;
  const { ticket, user } = req.body;

  //* Sanity Checks
  if (!inReq || !ticket || !user) {
    return res.status(400).send({ success: false, err: 'Incomplete Fields' });
  }
  try {
    let uid2 = req.ips[0] || req.ip;

    //* decrypt the request (data not http) using the key of this server
    let decReq = server.decryptReq(user, uid2, ticket, inReq);

    //* Then we verify that the random number used by user is used for the first time
    server.verifyRand(user, uid2, decReq.rand);

    //* Save the data in our mock DB, in real application we would operate with actual database here
    data.push(decReq.book);

    //* we encrypt the response (data not http)
    const encRes = server.encryptRes(user, uid2, ticket, {});

    //* Send the actual http response
    return res.status(200).send({ success: true, res: encRes });
  } catch (e) {
    //* If error is of type ServerError, it means ther is some error in decoding the req (data not http)
    if (e instanceof Kerberos.ServerError) {
      //? send the error as reponse, can be encrypted, but not done here
      return res.status(400).send({ success: false, err: e.message });
    } else {
      //* Some other error occurred
      throw e;
    }
  }
});

app.listen(EXPRESS_PORT, () => {
  console.log(`Express Book Server listening on Port ${EXPRESS_PORT}...`);
});
